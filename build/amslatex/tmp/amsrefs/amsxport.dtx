%%% ====================================================================
%%% @BibTeX-source-file{
%%%   filename  = "amsxport.dtx",
%%%   version   = "2.00",
%%%   date      = "2004/06/28",
%%%   time      = "14:50:12 EDT",
%%%   author    = "Michael J Downes",
%%%   address   = "American Mathematical Society,
%%%                Publications Technical Group,
%%%                PO Box 6248,
%%%                Providence, RI 02940,
%%%                USA",
%%%   email     = "tech-support at ams.org",
%%%   URL       = "http://www.ams.org/",
%%%   abstract  = "The BibTeX style file amsxport.bst produces .bbl
%%%                entries where most of the database structure is
%%%                retained. This is intended for processing by a smart
%%%                bibliography package such as the amsrefs package.",
%%%   checksum  = "40425 1822 6396 51551",
%%%   docstring = "The checksum field, produced by Robert Solovay's
%%%                checksum utility, gives CRC-16 checksum, lines,
%%%                words, and characters.",
%%%  }
%%% ====================================================================
% \iffalse
%<*driver>
\NeedsTeXFormat{LaTeX2e}
\documentclass[draft,oneside]{amsdtx}[1999/11/01]

\providecommand{\vn}[1]{\emph{#1}}% variable name

\renewcommand*\descriptionlabel[1]{\hspace\labelsep
                                \normalfont\bfseries #1:}

%% Use normal typesize instead of \small for code listings.

\def\MacroFont{%
    \fontencoding\encodingdefault
    \fontfamily\ttdefault
    \fontseries\mddefault
    \upshape
}

\makeatletter

%% Don't prepend \ to macro names.

\def\SpecialIndex@#1#2{%
   \@SpecialIndexHelper@#1\@nil
   \def\@tempb{ }%
   \ifcat \@tempb\@gtempa
      \special@index{\quotechar\space\actualchar
                     \string\verb\quotechar*\verbatimchar
                     \quotechar\space\verbatimchar#2}%
   \else
     \def\@tempb##1##2\relax{\ifx\relax##2\relax
          \def\@tempc{\special@index{\quotechar##1\actualchar
                      \string\verb\quotechar*\verbatimchar
                      \quotechar##1\verbatimchar#2}}%
        \else
          \def\@tempc{\special@index{##1##2\actualchar
                       \string\verb\quotechar*\verbatimchar
                       ##1##2\verbatimchar#2}}%
        \fi}%
     \expandafter\@tempb\@gtempa\relax
     \@tempc
   \fi}

\makeatother

\PageIndex

\begin{document}
\title{The AMS Export Bib\TeX{} style [\fn{amsxport}]}
\author{American Mathematical Society\\Michael Downes\\David M. Jones}
\date{Version \fileversion, \filedate}
\hDocInput{amsxport.dtx}
\PrintIndex
\end{document}
%</driver>
% \fi
%
% \MakeShortVerb{\|}
%
% \maketitle
%
% \tableofcontents
%
% \section{Introduction}
%
%    \bst{amsxport} is the collective name for a collection of
%    \bibtex/ styles that form a bridge between \BibTeX\ and
%    \pkg{amsrefs}. It produces output in which the structural
%    information of the original \bibtex/ database file is
%    retained. No ad hoc visual formatting is introduced that would
%    hamper the application of alternative design specifications when
%    rendering the information on paper or screen. This makes it
%    possible to have \bibtex/ handle only extraction and sorting and
%    leave the visual appearance to be controlled entirely by
%    \latex/. The process of applying typical bibliography specs to
%    exported data is illustrated in the \pkg{amsrefs} package. The
%    authoritative description of the export format is in the
%    \pkg{amsrefs} documentation, inasmuch as interpreting the format
%    is the chief task of the \pkg{amsrefs} package.
%
%    Each of the five \fn{.bst} files generated from this file
%    corresponds to a combination of \pkg{amsrefs} package options, as
%    follows:
%    \begin{description}
%
%    \item[amsrn]
%
%    This is the default style, used when none of the following is
%    appropriate.
%
%    \item[amsru]
%
%    This is used when the \opt{citation-order} option is specified.
%    It is identical to \bst{amsrn} except that the bibliography items
%    are not sorted.
%
%    \item[amsra]
%
%    This is when with the \opt{alphabetic} option is specified, byt
%    the \opt{y2k} option is \emph{not} also specified.
%
%    \item[amsry]
%
%    This is used when both the \opt{alphabetic} and \opt{y2k} options
%    are specified.
%
%    \item[amsrs]
%
%    This is used when the \opt{shortalphabetic} option is specified.
%
%    \end{description}
%
%    Readers may wish to refer also to the standard \bibtex/
%    documentation (\fn{btxdoc.tex}, \fn{btxhak.tex}, \fn{btxbst.doc})
%    for background information.
%
% \StopEventually{}
%
% \section{Implementation}
%
%    The list below gives the fields that are expected to occur. (Other
%    fields will be discarded without comment.)
%    suggested fields.
%    \begin{macrocode}
%<*bst>
ENTRY
  {
    address      institution  number       status
    archive      isbn         organization subtitle
    author       issn         pages        title
    booktitle    journal      part         translator
    chapter      key          pii          type
    date         language     preprint     url
    edition      meeting      publisher    volume
    editor       month        review       xid
    eprint       mrnumber     school       year
    howpublished note         series
  }
  { }
  { label }
%    \end{macrocode}
%
% Some comments about specific fields:
% \begin{description}
% \item[archive] The archive that holds the eprint listed in the
%    \fn{eprint} field.
% \item[author] \bibtex/ doesn't allow this field (or any field) to be
%    used more than once, but in the output its contents will be split
%    into a separate key-value pair for each name. Likewise for
%    \fn{editor} and \fn{translator}.
% \item[crossref] This is a built-in field type, so it doesn't occur in
%    the argument of ENTRY above.
% \item[date] This is a generalization of the \fn{year} and \fn{month}
%    fields. Its value should be written in ISO 8601 format, e.g.,
%    1987-06-05; but the day and month are omissible, so this can be
%    easily be used instead of the \fn{year} field.
% \item[edition] For books. The \bibtex/ documentation suggests that the
%    value of this field should be an ordinal word such as \qq{Second}.
%    This may be because the \bibtex/ language provides only the weakest
%    sort of support for an \emph{is-numeric} test.
% \item[eprint] Electronic preprint information such as for
%    \url{www.arXiv.org}.
% \item[institution] What's the difference between an \fn{institution}
%    and an \fn{organization}? The \bibtex/ documentation says that
%    \fn{institution} should be used for technical reports and
%    \fn{organization} for other entry types.
% \item[isbn] International Standard Book Number.
% \item[issn] International Standard Serial Number. See the discussion
%    of journal abbreviations.
% \item[language] Language of the work. This is especially desirable
%    when the value of the title field is a translation of the true
%    title (most often when the original language is one like Arabic or
%    Chinese that poses rendering problems for non-native software).
% \item[meeting] Since \bibtex/ doesn't allow a field name to be the
%    same as a function name, we have to use \fn{meeting} instead of
%    \fn{conference} if we want to give the title of a conference in a
%    dedicated field.
% \item[mrnumber] An alias for \fn{review} which we provide because
%    MathSciNet has been using it in the \bibtex/ output that it
%    provides for a couple of years already.
% \item[organization] See the comment for \fn{institution}.
% \item[pii] Publisher Item Identifier
% \item[part] This is for a long journal article that is published in
%    separate issues of the same journal. There should be a separate
%    \bibtex/ entry for each part (though all the ones after part 1
%    could crossref the first one).
%
% \item[preprint] It is not possible quite yet to assume that all
%    preprints should be classified as eprints. If you have a preprint
%    that is not an eprint, use this field to give the \qq{address}
%    where the preprint may be found (institution, preprint number,
%    etc.).
%
% \item[review] Review numbers or similar pointers, e.g., for
%    Mathematical Reviews or Zentralblatt.
%
% \item[school] The analog of \qq{organization}, for a thesis.
%
% \item[status] Typically used for notes such as ``to appear'' or ``in
%    preparation'' with journal articles.
%
% \item[subtitle] Typically used with a multipart journal article to
%    give a subtitle for each part.
%
% \item[translator] This needs no explanation, surely? Except perhaps to
%    note that the standard \bibtex/ styles don't provide it.
%
% \item[url] Universal Resource Locator.
%
% \item[xid] This is used by a cross-referenced item to pass its
%    identity to child entries that refer to it. It would not be
%    necessary if \bibtex/ left the \fn{crossref} field value
%    accessible, but for some reason that I have not found yet (skimming
%    in the source code) it is cleared internally before there is any
%    opportunity to save it.
%
%    Practically speaking: For every \fn{crossref} in your \fn{.bib}
%    files, the target should contain a matching \fn{xid} field.
%
% \end{description}
%
%    More on extra fields. In the Shelah bibliography, the \fn{author}
%    field is given without any accents in the author names, and the
%    normal \tex/ version of the author names is given in a separate
%    field called \fn{trueauthor}.
%
%    Also, for MR reviews:
%    \begin{verbatim}
%    review = {MR 48:3735},
%\end{verbatim}
%    And for each author a country is indicated with the \fn{fromwhere}
%    field, e.g.,
%    \begin{verbatim}
%    fromwhere = {UK, IL},
%\end{verbatim}
%    This means the first author is from the United Kingdom and the
%    second one from Israel.
%
% \section{Macros for month names}
%
%    \begin{macrocode}
MACRO {jan} {"-01"}
MACRO {feb} {"-02"}
MACRO {mar} {"-03"}
MACRO {apr} {"-04"}
MACRO {may} {"-05"}
MACRO {jun} {"-06"}
MACRO {jul} {"-07"}
MACRO {aug} {"-08"}
MACRO {sep} {"-09"}
MACRO {oct} {"-10"}
MACRO {nov} {"-11"}
MACRO {dec} {"-12"}
%    \end{macrocode}
%
%    Some scratch variables and global variables.
%    \begin{macrocode}
STRINGS { p s t l }
%    \end{macrocode}
%
%    \begin{macrocode}
INTEGERS { len ptr }
%<bst>
%    \end{macrocode}
%
%    \begin{footnotesize}\itshape
%    Note: \bibtex/ 0.99 requires a blank line in certain contexts, such
%    as after the \fn{READ} command, and will choke if it is missing.
%    When it is necessary to add a blank line at the boundary of a macro
%    code section we use a \verb'<bst>' marker.\par
%    \end{footnotesize}
%
%    Some utility functions.
%    \begin{macrocode}
FUNCTION {NOT} { { #0 } { #1 } if$ }

FUNCTION {AND} { 'skip$ { pop$ #0 } if$ }

FUNCTION {OR} { { pop$ #1 } 'skip$ if$ }

FUNCTION {TRUE} { #1 }

FUNCTION {FALSE} { #0 }
%<bst>
%    \end{macrocode}
%
%    \begin{macro}{incr.ptr}
%    \begin{macrocode}
FUNCTION {incr.ptr} { ptr #1 + 'ptr := }
%<bst>
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{current.char}
%    Returns: first character of STRING
%    \begin{macrocode}
FUNCTION {current.char} { ptr #1 substring$ }
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{copy.two.chars}
%    The function \fn{copy.two.chars} appends the next two characters
%    from s to STRING.
%
%    Arg: STRING (partial copy of pages string)
%
%    Returns: Modified version of STRING
%
%    Side effects: advances ptr
%    \begin{macrocode}
FUNCTION {copy.two.chars} { t * incr.ptr s current.char * incr.ptr }
%<bst>
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{is.digit}
%    \begin{macrocode}
FUNCTION {is.digit} {
    chr.to.int$
    duplicate$
    "0" chr.to.int$ #1 - >
    swap$
    "9" chr.to.int$ #1 + <
    AND
}
%<bst>
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{is.lowercase.letter}
%    In a previous implementation the \fn{is.letter} function first
%    lowercased the character using \verb'change.case$', then tested it
%    against the range a--z. But \verb'change.case$' issues a warning if
%    it is applied to a lone brace character.
%    \begin{macrocode}
FUNCTION {is.lowercase.letter} {
    chr.to.int$ duplicate$
    "a" chr.to.int$ #1 - >
    swap$
    "z" chr.to.int$ #1 + <
    AND
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{is.uppercase.letter}
%    \begin{macrocode}
FUNCTION {is.uppercase.letter} {
    chr.to.int$ duplicate$
    "A" chr.to.int$ #1 - >
    swap$
    "Z" chr.to.int$ #1 + <
    AND
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{is.letter}
%    \begin{macrocode}
FUNCTION {is.letter} {
    duplicate$
    is.lowercase.letter
        { pop$ TRUE }
        { is.uppercase.letter }
    if$
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{skip.accent}
%    This implementation of \fn{skip.accent} simply skips ahead one
%    character whenever a backslash is found. This handles things like
%    \verb'\v', \verb'\u', \verb'\k', \verb'\r'. Although this is overly
%    simplistic it is still an improvement over the previous method
%    which was to not even make the attempt. [mjd,2001-10-27]
%    \begin{macrocode}
FUNCTION {skip.accent} { pop$ incr.ptr }
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{strip.label}
%    \begin{macrocode}
FUNCTION {strip.label} {
    's :=
    #1 'ptr :=
    ""
    { s ptr #1 substring$ duplicate$ empty$ NOT }
        { duplicate$ is.letter
            { * }
            { duplicate$ "\" =
                { skip.accent }
                'pop$
              if$
            }
          if$
          incr.ptr
        }
    while$
%    \end{macrocode}
%    When the loop ends we have an extra empty-string on top of the
%    stack to get rid of.
%    \begin{macrocode}
    pop$
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{sortify}
%    \begin{macrocode}
FUNCTION {sortify} {
    purify$
    "l" change.case$
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{rpad}
%    Warning: The use of |text.length$| here and in \fn{lpad}
%    restricts their use to strings that we know do not contain any
%    special characters.  Since we only use \fn{lpad} for field names
%    and \fn{rpad} for |purify$|ed strings, this is ok.
%
%    \<string> \<int> \fn{rpad}
%    \begin{macrocode}
FUNCTION {rpad} {
    swap$
    'l :=
    l text.length$ - 'len :=
    { len #0 > }
        {
            l " " * 'l :=
            len #1 - 'len :=
        }
    while$
    l
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{lpad}
%    \<string> \<int> \fn{lpad}
%    \begin{macrocode}
FUNCTION {lpad} {
    swap$
    'l :=
    l text.length$ - 'len :=
    { len #0 > }
        {
            " " l * 'l :=
            len #1 - 'len :=
        }
    while$
    l
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{field.or.null}
%    \begin{macrocode}
FUNCTION {field.or.null} {
    duplicate$ empty$
        { pop$ "" }
        'skip$
    if$
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{missing.or.empty}
%    \begin{macrocode}
FUNCTION {missing.or.empty} { duplicate$ missing$ swap$ empty$ OR }
%<bst>
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{append.ndash.and.skip.hyphens}
%    The function \fn{append.ndash.and.skip.hyphens} adds \verb'\ndash'
%    to STRING when a hyphen is found and advances ptr to the next
%    non-hyphen character in \fn{s}.
%
%    Arg: STRING (partial copy of pages string)
%
%    Returns: modified version of STRING
%
%    Side effects: advances ptr
%    \begin{macrocode}
FUNCTION {append.ndash.and.skip.hyphens} {
    "\ndash " *
    incr.ptr
    { s current.char "-" = }
        { incr.ptr }
    while$
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{n.dashify}
%    In the \fn{n.dashify} function we store the given string in \fn{s},
%    push an empty string on the stack, and start examining the
%    characters of \fn{s}. For a non-hyphen character, we just append a
%    copy of it to the top string. For a hyphen, we append \cs{ndash} to
%    the top string and advance the pointer until we reach a non-hyphen
%    character. And there is one more exceptional case: for a backslash,
%    we copy two characters instead of one. This keeps us from
%    erroneously translating \verb'\-' to \verb'\\ndash'. One would
%    scarcely expect to see an instance of \verb'\-' in a page number
%    field but let's face it, in actual use nearly anything can and does
%    happen.
%
%    Arg: STRING (value of \fn{pages} field)
%
%    Returns: STRING (dashified version of input string)
%    \begin{macrocode}
FUNCTION {n.dashify} {
    's :=
    #1 'ptr :=
    ""
    { s current.char 't :=  t "" = NOT }
      { t "\" =
          { copy.two.chars }
          { t "-" =
              { append.ndash.and.skip.hyphens }
              { t * incr.ptr }
            if$
          }
        if$
      }
    while$
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{missing.warning}
%    Standard warning message for a missing or empty field. For the user
%    we call any such field `missing' without respect to the distinction
%    made by \bibtex/ between missing and empty.
%    \begin{macrocode}
FUNCTION {missing.warning} {
    "missing " swap$ * " in " * cite$ * warning$
}
%<bst>
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{string.length}
%    Because \bibtex/ doesn't provide a straightforward
%    \fn{string.length} function (\verb'text.length$' counts ``special
%    characters'' as a single character), it appears necessary to
%    implement one the hard way.
%    \begin{macrocode}
INTEGERS { string.ptr }

FUNCTION {string.length} {
    #1 'string.ptr :=
    { duplicate$ string.ptr #1 substring$ "" = 'FALSE 'TRUE if$ }
        { string.ptr #1 + 'string.ptr := }
    while$
    pop$
    string.ptr #1 -
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{format.title}
%    \begin{macrocode}
FUNCTION {format.title}{
    duplicate$
    missing.or.empty
        { pop$ "" }
        { "t" change.case$ }
    if$
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{start.field}
%    \begin{macrocode}
FUNCTION {start.field} {
    #12 lpad "={" * write$
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{fin.field}
%    \begin{macrocode}
FUNCTION {fin.field} { "}," write$ newline$ }
%<bst>
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{write.field}
%    \begin{macrocode}
FUNCTION {write.field} {
    duplicate$
    missing$
        { pop$ missing.warning }
        { duplicate$ empty$
            { pop$ missing.warning }
            { swap$ start.field write$ fin.field }
          if$
        }
    if$
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{optional.field}
%    \begin{macrocode}
FUNCTION {optional.field} {
    duplicate$
    missing.or.empty
        { pop$ pop$ }
        { swap$ start.field write$ fin.field }
    if$
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{optional.title.field}
%    \begin{macrocode}
FUNCTION {optional.title.field} {
    duplicate$
    missing.or.empty
        { pop$ pop$ }
        { format.title swap$ start.field write$ fin.field }
    if$
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{optional.pages.field}
%    \begin{macrocode}
FUNCTION {optional.pages.field} {
    duplicate$
    missing.or.empty
        { pop$ pop$ }
        { swap$ start.field
          n.dashify
          write$ fin.field
        }
    if$
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{optional.mr.field}
%    \begin{macrocode}
FUNCTION {optional.mr.field} {
    duplicate$
    missing.or.empty
        { pop$ pop$ }
        {
          swap$ start.field
          "\MR{" swap$ * "}" * write$ fin.field
        }
    if$
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{remove.ordinal.suffix}
%    \begin{macrocode}
FUNCTION {remove.ordinal.suffix} {
    's :=
    s string.length 'len :=
    #1 'ptr :=
    { ptr len < s ptr #1 substring$ is.digit AND }
        'incr.ptr
    while$
    s ptr global.max$ substring$ 'p :=
    p "st" =
        { TRUE }
        { p "nd" =
            { TRUE }
            { p "rd" =
                { TRUE }
                { p "th" =
                    { TRUE }
                    { FALSE }
                  if$
                }
              if$
            }
          if$
        }
    if$
    { s #1 ptr #1 - substring$ }
    { s }
  if$
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{optional.edition.field}
%    \begin{macrocode}
FUNCTION {optional.edition.field} {
    duplicate$ missing.or.empty
        { pop$ pop$ }
        { swap$ start.field
          remove.ordinal.suffix
          write$ fin.field
        }
    if$
}
%    \end{macrocode}
%    \end{macro}
%
% \section{Formatting author names and editor names}
%
%    Take a name list in \bibtex/ form (names separated by the word
%    \qq{and}) and output the desired form of each name.
%    \begin{macrocode}
INTEGERS { nameptr numnames namesleft }
STRINGS { namelist fieldname }
%    \end{macrocode}
%
%    \begin{macro}{format.name}
%    The \fn{format.name} function operates on a single name, producing
%    a string of the form
%    \begin{verbatim}
%    von Last, First, Jr.
%\end{verbatim}
%
%    Args: \vn{namelist}, \vn{index} (top; integer)
%
%    Returns: formatted version of the $n$th name in \vn{namelist} where
%    integer \vn{index} specifies $n$.
%    \begin{macrocode}
FUNCTION {format.name} { "{vv~}{ll}{, ff}{, jj}" format.name$ }
%<bst>
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{optional.name.field}
%    The function \fn{optional.name.field} handles the task of splitting
%    a multiple-name field value into multiple fields with single
%    values.
%
%    Args: \vn{fieldname}, \vn{namelist} (top)
%
%    Side effects: writes a key/value pair to the output file for each
%    name in \vn{namelist}.
%    \begin{macrocode}
FUNCTION {optional.name.field}{
    duplicate$ missing.or.empty
        { pop$ pop$ }
        { swap$ 'fieldname :=
          duplicate$ num.names$
          'namesleft :=
          #1 'ptr :=
          { namesleft #0 > }
            { fieldname start.field
%    \end{macrocode}
%    Copy the name string before running \fn{format.name} on it.
%    \begin{macrocode}
              duplicate$ ptr format.name write$
              fin.field
              ptr #1 + 'ptr :=
              namesleft #1 - 'namesleft :=
            }
          while$
%    \end{macrocode}
%    At this point we have an extra copy of the name string on the
%    stack.
%    \begin{macrocode}
        pop$
        }
    if$
}
%    \end{macrocode}
%    \end{macro}
%
% \section{Handling year, month, date}
%
%    \begin{macro}{assemble.date.field}
%    In the output we produce a \fn{date} field instead of the year and
%    month fields normally used in \bibtex/ files. In the date field we
%    use ISO date notation (e.g., 1987-06-05) to facilitate switching
%    between full and abbreviated month names. The month and day parts
%    are frequently absent, making the date field equivalent to a year
%    field.
%    \begin{macrocode}
FUNCTION {assemble.date.field}
{ date missing$
    { year missing.or.empty
        { status missing.or.empty
            { "No year or other date information for "
               cite$ * warning$ }
            'skip$
          if$
          "status"
        }
        { year month missing$ { "" } { month } if$ * }
      if$
    }
    { date }
  if$
%    \end{macrocode}
%    If the date string is now equal to \qq{status}, it means that we
%    have a status field or we already gave a warning about lack of date
%    info; in either case omit the date field.
%    \begin{macrocode}
  duplicate$ "status" =
    { pop$ pop$ }
    { swap$ start.field write$ fin.field }
  if$
}
%    \end{macrocode}
%    \end{macro}
%
% \section{Journal abbreviations}
%
%    Use of journal abbreviations is recommended to make supplying ISSN
%    numbers easier. To use this feature, you need a STRING definition
%    of the form
%    \begin{verbatim}
%    @STRING{cpam="cpam/0010-3640/"
%            #"Communications in Pure and Applied Mathematics"}
%\end{verbatim}
%    Then when you write
%    \begin{verbatim}
%    journal=cpam,
%\end{verbatim}
%    exporting with \fn{amsxport} will produce
%    \begin{verbatim}
%    journal={cpam},
%    ISSN={0010-3640},
%\end{verbatim}
%    The text before the ISSN number in the STRING definition is
%    preferably a repetition of the abbreviation name (leaving expansion
%    to be done on the \latex/ side); or it could be the full journal
%    name.
%
%    \textbf{Warning:} If you include braces and write
%    \verb'journal={cpam},' \bibtex/ will not expand the abbreviation
%    but leave it as the field value; and then you will not get
%    automatic lookup of the ISSN number.
%
%    \begin{macro}{optional.journal.field}
%    \begin{macrocode}
FUNCTION {optional.journal.field} {
    duplicate$ missing.or.empty
        { pop$ pop$ }
        {
            's :=
            start.field
            #1 'ptr :=
            s current.char is.lowercase.letter
                {
                    s "/" * 's :=
                    { s ptr #1 substring$ "/" = NOT }
                        { incr.ptr }
                    while$
%    \end{macrocode}
%    Journal name started with a lowercase letter, but we couldn't find
%    no slash? All right, just let it go through as it is.
%    \begin{macrocode}
                    s ptr #1 + #1 substring$ empty$
                        { s #1 ptr #1 - substring$ }
%    \end{macrocode}
%    But if we did find a slash, then we probably have found us an ISSN
%    number that we can write out.
%    \begin{macrocode}
                        {
                            s #1 ptr #1 - substring$
                            write$
                            fin.field
%    \end{macrocode}
%    ISSNs are always nine characters in length (four digits, hyphen,
%    four digits).
%    \begin{macrocode}
                            "ISSN" start.field
                            s ptr #1 + #9 substring$
                        }
                    if$
                }
                { s }
            if$
            write$
            fin.field
        }
    if$
}
%    \end{macrocode}
%    \end{macro}
%
% \section{Type info}
%
%    \begin{macro}{optional.type.field}
%    Putz around with the type info a little, for theses mainly. Two
%    types here: the type field, and the entry type.
%    \begin{macrocode}
FUNCTION {optional.type.field}
{ duplicate$ missing.or.empty
    { type$ "mastersthesis" = { "Master's Thesis" }
        { type$ "phdthesis" = { "Ph.D. Thesis" }
          { "" } if$ } if$
      swap$ pop$
    }
    'skip$
  if$
  duplicate$ empty$
    { pop$ pop$ }
    { swap$ start.field write$ fin.field }
  if$
}
%    \end{macrocode}
%    \end{macro}
%
% \section{Miscellaneous tail-end information}
%
%    \begin{macro}{url.note.status.review}
%    The following items are common to all entry types are output at
%    the tail end of the entry.
%    \begin{macrocode}
FUNCTION {url.note.status.review} {
    "url" url optional.field
    "note" note optional.field
    "status" status optional.field
%    \end{macrocode}
%    The \fn{review} field should perhaps be translated into multiple
%    fields like author names, if more than one review is given.
%    \begin{macrocode}
    "review" review optional.field
%    \end{macrocode}
%    Data from MathSciNet will have the Math Reviews number in an
%    mrnumber field. We assume that a given entry will have a review
%    field or an mrnumber field but not both.
%    \begin{macrocode}
    "review" mrnumber optional.mr.field
}
%    \end{macrocode}
%    \end{macro}
%
% \section{Wrapper for each entry}
%
%    \begin{macro}{start.entry}
%    \begin{macrocode}
FUNCTION {start.entry} {
    newline$
    "\bib{" cite$ * "}{" *
%    \end{macrocode}
%    Merge Master's thesis and Ph.D. thesis into a single type.
%    \begin{macrocode}
    type$ "mastersthesis" = type$ "phdthesis" =  OR
        { "thesis" }
        { type$ }
    if$
    * "}{" * write$
    newline$
%<*debug>
    "sort.label" label sortify optional.field
    "sort.key" sort.key$ optional.field
%</debug>
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{fin.entry}
%    \begin{macrocode}
FUNCTION {fin.entry} {
    "}" write$
    newline$
}
%    \end{macrocode}
%    \end{macro}
%
% \section{Entry types}
%
%    Here are the types of entries that are normally allowed in a
%    \bibtex/ file:
% \begin{description}
%
% \item[book] A book with an explicit publisher.
%
% \item[booklet] A work that is printed and bound, but without a named
%    publisher or sponsoring institution.
%
% \item[inbook] A part of a book, which may be a chapter (or section or
%    whatever) and/or a range of pages.
%
% \item[incollection] A part of a book having its own title.
%
% \item[manual] Technical documentation.
%
% \item[mastersthesis] A Master's thesis.
%
% \item[phdthesis] A PhD thesis.
%
% \item[proceedings] The proceedings of a conference.
%
% \item[techreport] A report published by a school or other institution,
%    usually numbered within a series.
%
% \item[article] An article from a journal or magazine.
%
% \item[inproceedings] An article in a conference proceedings.
%
% \item[conference] An alias for \fn{inproceedings}.
%
% \item[unpublished] A document having an author and title, but not
%    formally published.
%
% \item[misc] Use this type when nothing else fits.
%
% \end{description}
%
%    \begin{macro}{article}
%    A journal article differs from an inproceedings article by not
%    having booktitle, publisher, editor, and other such info.
%    \begin{macrocode}
FUNCTION {article} {
    start.entry
    "author" author optional.name.field
    "translator" translator optional.name.field
    "title" title format.title write.field
    "subtitle" subtitle optional.title.field
    "language" language optional.field
    "organization" organization optional.field
    "how" howpublished optional.field
%    \end{macrocode}
%    Construct a date value from date, year, month fields
%    \begin{macrocode}
    "date" assemble.date.field
    "ISSN" issn optional.field
    "journal" journal optional.journal.field
    "volume" volume optional.field
    "number" number optional.field
    "pages" pages optional.pages.field
    "PII" pii optional.field
    "archive" archive optional.field
    "eprint" eprint optional.field
    "preprint" preprint optional.field
    url.note.status.review
    fin.entry
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{inproceedings}
%    An inproceedings entry may have xid, booktitle, meeting, publisher
%    info; it is not expected to have journal, eprint, or preprint info.
%    \begin{macrocode}
FUNCTION {inproceedings} {
    start.entry
    "author" author optional.name.field
    "translator" translator optional.name.field
    "title" title format.title write.field
    "subtitle" subtitle optional.title.field
    "language" language optional.field
    "organization" organization optional.field
    "how" howpublished optional.field
%    \end{macrocode}
%    Construct a date value from date, year, month fields
%    \begin{macrocode}
    "date" assemble.date.field
    "xid" xid optional.field
%    \end{macrocode}
%    The following fields might be inherited from the parent of an
%    article in a proceedings volume or collection.
%    \begin{macrocode}
    "conference" meeting optional.field
    "booktitle" booktitle optional.title.field
%    \end{macrocode}
%    Include the edition in case this is an inbook entry.
%    \begin{macrocode}
    "edition" edition optional.edition.field
    "editor" editor optional.name.field
    "series" series optional.field
    "volume" volume optional.field
    "publisher" publisher optional.field
    "address" address optional.field
    "pages" pages optional.pages.field
    url.note.status.review
    fin.entry
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{inbook}
%    \begin{macrocode}
FUNCTION {inbook} { inproceedings }
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{incollection}
%    \begin{macrocode}
FUNCTION {incollection} { inproceedings }
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{inproceedings}
%    \begin{macrocode}
FUNCTION {conference} { inproceedings }
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{book}
%    The book type includes a meeting field because otherwise we'd have
%    to repeat the entire definition for the proceedings type with that
%    as the sole difference.
%    \begin{macrocode}
FUNCTION {book} {
    start.entry
    "author" author optional.name.field
    "editor" editor optional.name.field
    "translator" translator optional.name.field
    "title" title missing$ { booktitle } { title } if$
       format.title write.field
    "subtitle" subtitle optional.title.field
    "type" type optional.type.field
    "language" language optional.field
    "conference" meeting optional.field
    "edition" edition optional.edition.field
    "series" series optional.field
    "publisher" publisher optional.field
    organization missing.or.empty
        { "institution" institution optional.field }
        { "organization" organization optional.field }
    if$
    "address" address optional.field
    "how" howpublished optional.field
    "date" year write.field
    "volume" volume optional.field
%    \end{macrocode}
%    The number here is intended for a tech report.
%    \begin{macrocode}
    "number" number optional.field
    "ISBN" isbn optional.field
    url.note.status.review
    fin.entry
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{booklet}
%    \begin{macrocode}{booklet}
FUNCTION {booklet} { book }
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{manual}
%    \begin{macrocode}
FUNCTION {manual} { book }
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{mastersthesis}
%    \begin{macrocode}
FUNCTION {mastersthesis} { book }

FUNCTION {phdthesis} { book }

FUNCTION {proceedings} { book }

FUNCTION {collection} { book }

FUNCTION {techreport} { book }

FUNCTION {unpublished} { book }

FUNCTION {misc} { book }

FUNCTION {default.type} { misc }
%<bst>
%    \end{macrocode}
%    \end{macro}
%
%    \bibtex/ 0.99 keels over if READ does not have a blank line after
%    it.
%    \begin{macrocode}
%<bst>
READ
%<bst>
%    \end{macrocode}
%
% \section{Sorting the entries}
%
%    Since the final labels will be produced by the \pkg{amsrefs}
%    package, we don't need to worry about generating suffixes to
%    disambiguate between equal stems.  All we have to do is strive to
%    generate stems that are identical to the ones that \pkg{amsrefs}
%    will generate, so that \bst{amsxport} will sort its output in a
%    fashion that will be consistent with the labels.
%
%    Overall, this simplifies our job, since we don't have to keep
%    track of duplicate labels, so we can process each entry in
%    isolation.  However, we do have to be more careful about the
%    handling of text accents and text symbols in order to maintain
%    compatibility with \pkg{amsrefs}.
%
%    See (\emph{inter alia}) the sections ``Lexical structure of
%    names'' and ``Generating alphabetic lables'' in the
%    \pkg{amsrefs} implementation documentation for more information.
%
%    \begin{macrocode}
%<*sort>
%    \end{macrocode}
%
%    \begin{macro}{chop.word}
%    \begin{macrocode}
FUNCTION {chop.word} {
    's :=
    'len :=
    s #1 len substring$ =
        { s len #1 + global.max$ substring$ }
        's
    if$
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{sort.format.title}
%    \begin{macrocode}
FUNCTION {sort.format.title} {
    't :=
    "A " #2
      "An " #3
        "The " #4 t chop.word
      chop.word
    chop.word
    sortify
    #1 global.max$ substring$
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{format.lab.names}
%    \begin{macrocode}
%<*alpha|short>
FUNCTION {format.lab.names} {
   's :=
    s num.names$ 'numnames :=
    numnames #1 >
      { numnames #4 >
          { #3 'namesleft := }
          { numnames 'namesleft := }
        if$
        #1 'nameptr :=
        ""
          { namesleft #0 > }
          { nameptr numnames =
              { s nameptr "{ff }{vv }{ll}{ jj}" format.name$ "others" =
                  { "{\etalchar{+}}" * }
                  { s nameptr "{v{}}{l{}}" format.name$ * }
                if$
              }
              { s nameptr "{v{}}{l{}}" format.name$ * }
            if$
            nameptr #1 + 'nameptr :=
            namesleft #1 - 'namesleft :=
          }
        while$
        numnames #4 >
          { "{\etalchar{+}}" * }
          'skip$
        if$
      }
      { s #1 "{v{}}{l{}}" format.name$
        duplicate$ text.length$ #2 <
%<alpha>          { pop$ s #1 "{ll}" format.name$ #3 text.prefix$ }
%<short>          { pop$ s #1 "{ll}" format.name$ #1 text.prefix$ }
          'skip$
        if$
      }
    if$
}

FUNCTION {author.key.label}
{ author empty$
    { key empty$
	{ cite$ #1 #3 substring$ }
	{ key #3 text.prefix$ }
      if$
    }
    { author format.lab.names }
  if$
}

FUNCTION {author.editor.key.label}
{ author empty$
    { editor empty$
	{ key empty$
	    { cite$ #1 #3 substring$ }
	    { key #3 text.prefix$ }
	  if$
	}
	{ editor format.lab.names }
      if$
    }
    { author format.lab.names }
  if$
}

FUNCTION {author.key.organization.label}
{ author empty$
    { key empty$
	{ organization empty$
	    { cite$ #1 #3 substring$ }
	    { "The " #4 organization chop.word #3 text.prefix$ }
	  if$
	}
	{ key #3 text.prefix$ }
      if$
    }
    { author format.lab.names }
  if$
}

FUNCTION {editor.key.organization.label}
{ editor empty$
    { key empty$
	{ organization empty$
	    { cite$ #1 #3 substring$ }
	    { "The " #4 organization chop.word #3 text.prefix$ }
	  if$
	}
	{ key #3 text.prefix$ }
      if$
    }
    { editor format.lab.names }
  if$
}

FUNCTION {calc.label}{
    type$ "book" =  type$ "inbook" =  OR
    'author.editor.key.label
    { type$ "proceedings" =
	'editor.key.organization.label
	{ type$ "manual" =
	    'author.key.organization.label
	    'author.key.label
	  if$
	}
      if$
    }
    if$
    strip.label
    sortify
%<*alpha>
    year field.or.null
%<!y2k>    #3 #8 substring$
    purify$ *
%</alpha>
    'label :=
}
%</alpha|short>
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{sort.format.names}
%    \begin{macrocode}
FUNCTION {sort.format.names} {
    's :=
    #1 'ptr :=
    ""
    s num.names$ 'numnames :=
    numnames 'namesleft :=
      { namesleft #0 > }
      { ptr #1 >
          { " " * }
          'skip$
        if$
        s ptr "{ll}{ ff}{ jj}" format.name$ 't :=
        ptr numnames = t "others" = AND
          { "et al" }
          { t sortify }
        if$
        #20 rpad *
        ptr #1 + 'ptr :=
        namesleft #1 - 'namesleft :=
      }
    while$
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{sort.warning}
%    \begin{macrocode}
FUNCTION {sort.warning} {
    "to sort, need " swap$ * " or key in " * cite$ * warning$
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{author.sort}
%    \begin{macrocode}
FUNCTION {author.sort}
{ author empty$
    { key empty$
        { "author" sort.warning
          ""
        }
        { key sortify }
      if$
    }
    { author sort.format.names }
  if$
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{author.editor.sort}
%    \begin{macrocode}
FUNCTION {author.editor.sort}
{ author empty$
    { editor empty$
        { key empty$
            { "author, editor," sort.warning
              ""
            }
            { key sortify }
          if$
        }
        { editor sort.format.names }
      if$
    }
    { author sort.format.names }
  if$
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{author.organization.sort}
%    \begin{macrocode}
FUNCTION {author.organization.sort}
{ author empty$
    { organization empty$
        { key empty$
            { "author, organization," sort.warning
              ""
            }
            { key sortify }
          if$
        }
        { "The " #4 organization chop.word sortify }
      if$
    }
    { author sort.format.names }
  if$
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{editor.organization.sort}
%    \begin{macrocode}
FUNCTION {editor.organization.sort}
{ editor empty$
    { organization empty$
        { key empty$
            { "editor, organization," sort.warning
              ""
            }
            { key sortify }
          if$
        }
        { "The " #4 organization chop.word sortify }
      if$
    }
    { editor sort.format.names }
  if$
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{presort}
%    \begin{macrocode}
FUNCTION {presort} {
%<*alpha|short>
    calc.label
    label #20 rpad
%</alpha|short>
    type$ "book" = type$ "inbook" = OR type$ "collection" = OR
        'author.editor.sort
        { type$ "proceedings" =
            'editor.organization.sort
            { type$ "manual" =
                'author.organization.sort
                'author.sort
              if$
            }
          if$
        }
    if$
%<alpha|short>    * " " *
%<!alpha|short>    year field.or.null sortify #12 rpad * " " *
    title field.or.null sort.format.title *
    #1 entry.max$ substring$
    'sort.key$ :=
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macrocode}
ITERATE {presort}

SORT
%    \end{macrocode}
%
%    \begin{macrocode}
%</sort>
%    \end{macrocode}
%
% \section{Final pass for output}
%
%    \begin{macro}{write.with.newlines}
%    The \fn{write.with.newlines} functions stores a string in \fn{s}
%    and runs through it looking for occurrences of \verb'^^M'; when one
%    is found, the substring before it is written out with a newline,
%    the remainder is left in \fn{s}, and the cycle begins again.
%    \begin{macrocode}
FUNCTION {write.with.newlines}
{ 's :=  #1 'ptr :=
  { s ptr #2 + #1 substring$ "" = NOT }
  { s ptr #3 substring$ "^^M" =
    { s #1 ptr #1 - substring$ write$ newline$
      ptr #3 + 'ptr :=
      s ptr global.max$ substring$ 's :=
      #1 'ptr :=
    }
    { incr.ptr }
    if$
  }
  while$
  s write$ newline$
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{begin.bin}
%    \begin{macrocode}
FUNCTION {begin.bib} {
    preamble$ empty$
        'skip$
        { preamble$ write.with.newlines }
    if$
    "% \bib, bibdiv, biblist are defined by the amsrefs package."
        write$ newline$
    "\begin{bibdiv}" write$ newline$
    "\begin{biblist}" write$ newline$
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macro}{end.bin}
%    \begin{macrocode}
FUNCTION {end.bib} {
    newline$
    "\end{biblist}" write$ newline$
    "\end{bibdiv}" write$ newline$
}
%    \end{macrocode}
%    \end{macro}
%
%    \begin{macrocode}
EXECUTE {begin.bib}

ITERATE {call.type$}

EXECUTE {end.bib}
%</bst>
%    \end{macrocode}
%
% \section{Journal abbreviations}
%
%    By putting the ISSN into the \latex/ document, we make it easier to
%    construct www queries from the bibliography data. These string
%    definitions tie together journal abbreviations, ISSN numbers, and
%    journal names.
%
% These are the journals that are cited most frequently by American
% Mathematical Society authors at the present time (2000 CE).
%
% The format used here is designed to make it easy for BibTeX
% to retrieve an ISSN number when given a journal abbreviation.
%    \begin{macrocode}
%<*abbrevs>
@string{aa="aa/0065-1036/"
  #"Acta Arithmetica"}
@string{actamath="actamath/0001-5962/"
  #"Acta Mathematica"}
@string{asms="asms/0001-6969/"
  #"Acta Scientiarum Mathematicarum"}
@string{advmath="advmath/0001-8708/"
  #"Advances in Mathematics"}
@string{ajm="ajm/0002-9327/"
  #"American Journal of Mathematics"}
@string{amm="amm/0002-9890/"
  #"American Mathematical Monthly"}
@string{aifg="aifg/0373-0956/"
  #"Annales de l'Institut Fourier"}
@string{am2="am2/0003-486X/Annals of Mathematics"}
@string{ap="ap/0091-1798/"
  #"The Annals of Probability"}
@string{asens4="asens4/0012-9593/"
  #"Annales Scientifiques de l'\'{E}cole Normale Sup\'{e}rieure"}
@string{amb="amb/0003-889X/Archiv der Mathematik"}
@string{arma="arma/0003-9527/"
  #"Archive for Rational Mechanics and Analysis"}
@string{bamsn="bamsn/0273-0979/"
  #"Bulletin (New Series) of the American Mathematical Society"}
@string{bams="bams/0004-9727/"
  #"Bulletin of the Australian Mathematical Society"}
@string{blms="blms/0024-6093/"
  #"Bulletin of the London Mathematical Society"}
@string{bsmf="bsmf/0037-9484/"
  #"Bulletin de la Soci\'{e}t\'{e} Math\'{e}matique de France"}
@string{craspi="craspi/0764-4442/"
  #"Comptes Rendus de l'Acad\'{e}mie des Sciences (Paris)"
  #" S\'{e}rie I Math\'{e}matique"}
@string{cjm="cjm/0008-414X/Canadian Journal of Mathematics"}
@string{cmb="cmb/0008-4395/"
  #"Canadian Mathematical Bulletin"}
@string{colloqmath="colloqmath/0010-1354/"
  #"Colloquium Mathematicum"}
@string{commalgebra="commalgebra/0092-7872/"
  #"Communications in Algebra"}
@string{cmp="cmp/0010-3616/"
  #"Communications in Mathematical Physics"}
@string{cpam="cpam/0010-3640/"
  #"Communications on Pure and Applied Mathematics"}
@string{cmh="cmh/0010-2571/"
  #"Commentarii Mathematici Helvetici"}
@string{cvta="cvta/0278-1077/"
  #"Complex Variables"}
@string{compositiomath="compositiomath/0010-437X/"
  #"Compositio Mathematica"}
@string{c="c/0010-485X/Computing"}
@string{constrapprox="constrapprox/0176-4276/"
  #"Constructive Approximation"}
@string{dmj="dmj/0012-7094/"
  #"Duke Mathematical Journal"}
@string{eraams="eraams/1079-6762/"
  #"Electronic Research Announcements"
  #" of the American Mathematical Society"}
@string{etds="etds/0143-3857/"
  #"Ergodic Theory and Dynamical Systems"}
@string{fm="fm/0016-2736/"
  #"Fundamenta Mathematicae"}
@string{gd="gd/0046-5755/"
  #"Geometriae Dedicata"}
@string{illinoisjmath="illinoisjmath/0019-2082/"
  #"Illinois Journal of Mathematics"}
@string{iumj="iumj/0022-2518/"
  #"Indiana University Mathematics"}
@string{im="im/0020-9910/"
  #"Inventiones Mathematicae"}
@string{israeljmath="israeljmath/0021-2172/"
  #"Israel Journal of Mathematics"}
@string{iansm="iansm/??/"
  #"Izvestiya Akademii Nauk SSSR. Seriya Matematicheskaya"}
@string{ja="ja/0021-8693/"
  #"Journal of Algebra"}
@string{jams="jams/0894-0347/"
  #"Journal of the American Mathematical Society"}
@string{jam="jam/0021-7670/"
  #"Journal d'Analyse Math\'{e}matique"}
@string{jamm="jamm/0021-8928/"
  #"Journal of Applied Mathematics and Mechanics"}
@string{jat="jat/0021-9045/"
  #"Journal of Approximation Theory"}
@string{jamsa="jamsa/0263-6115/"
  #"Journal of the Australian Mathematical Society"}
@string{jcta="jcta/0097-3165/"
  #"Journal of Combinatorial Theory"}
@string{jde="jde/0022-0396/"
  #"Journal of Differential Equations"}
@string{jdg="jdg/0022-040X/Journal of Differential Geometry"}
@string{jfa="jfa/0022-1236/"
  #"Journal of Functional Analysis"}
@string{jlms2="jlms2/0024-6107/"
  #"Journal of the London Mathematical Society"}
@string{jmaa="jmaa/0022-247X/"
  #"Journal of Mathematical Analysis and Applications"}
@string{jmp="jmp/0022-2488/"
  #"Journal of Mathematical Physics"}
@string{jmsj="jmsj/0025-5645/"
  #"Journal of the Mathematical Society of Japan"}
@string{jnt="jnt/0022-314X/Journal of Number Theory"}
@string{jot="jot/0379-4024/"
  #"Journal of Operator Theory"}
@string{jpaa="jpaa/0022-4049/"
  #"Journal of Pure and Applied Algebra"}
% Braces instead of quotes, to hide the embedded \" control sequence
@string{jram={jram/0075-4102/}
  #{Journal f\"{u}r die Reine und Angewandte Mathematik}}
@string{jsl="jsl/0022-4812/"
  #"The Journal of Symbolic Logic"}
@string{laa="laa/0024-3795/"
  #"Linear Algebra and its Applications"}
@string{mm="mm/0025-2611/"
  #"Manuscripta Mathematica"}
@string{matzametki="matzametki/0025-567X/Matematicheskie Zametki"}
@string{ma="ma/0025-5831/"
  #"Mathematische Annalen"}
@string{mc="mc/0025-5718/"
  #"Mathematics of Computation"}
@string{mj="mj/0025-5513/"
  #"Mathematica Japonica"}
@string{mn="mn/0025-584X/Mathematische Nachrichten"}
@string{mpcps="mpcps/0305-0041/"
  #"Mathematical Proceedings of the"
  #" Cambridge Philosophical Society"}
@string{mrl="mrl/1073-2780/"
  #"Mathematical Research Letters"}
@string{ms="ms/0025-5521/"
  #"Mathematica Scandinavica"}
@string{mathz="mathz/0025-5874/"
  #"Mathematische Zeitschrift"}
@string{m="m/0025-5793/"
  #"Mathematika"}
@string{mmj="mmj/0026-2285/"
  #"The Michigan Mathematical Journal"}
@string{nmj="nmj/0027-7630/"
  #"Nagoya Mathematical Journal"}
@string{na="na/0362-546X/Nonlinear Analysis"}
@string{nm="nm/0029-599X/Numerische Mathematik"}
@string{ojm="ojm/0030-6126/"
  #"Osaka Journal of Mathematics"}
@string{pjm="pjm/0030-8730/"
  #"Pacific Journal of Mathematics"}
@string{pams="pams/0002-9939/"
  #"Proceedings of the American Mathematical Society"}
@string{pems2="pems2/0013-0915/"
  #"Proceedings of the Edinburgh Mathematical Society"}
@string{pjaa="pjaa/0386-2194/"
  #"Proceedings of the Japan Academy"}
@string{plms3="plms3/0024-6115/"
  #"Proceedings of the London Mathematical Society"}
@string{qjmo2="qjmo2/0033-5606/"
  #"The Quarterly Journal of Mathematics"}
@string{rmi="rmi/0213-2230/"
  #"Revista Matem\'{a}tica Iberoamericana"}
@string{rmjm="rmjm/0035-7596/"
  #"Rocky Mountain Journal of Mathematics"}
@string{sjam="sjam/0036-1399/"
  #"SIAM Journal on Applied Mathematics"}
@string{sjc="sjc/0097-5397/"
  #"SIAM Journal on Computing"}
@string{sjma="sjma/0036-1410/"
  #"SIAM Journal on Mathematical Analysis"}
@string{sjna="sjna/0036-1429/"
  #"SIAM Journal on Numerical Analysis"}
@string{sr="sr/0036-1445/"
  #"SIAM Review"}
@string{sm="sm/0039-3223/"
  #"Studia Mathematica"}
@string{tjm="tjm/0387-3870/"
  #"Tokyo Journal of Mathematics"}
@string{ta="ta/0166-8641/"
  #"Topology and its Applications"}
@string{t="t/0040-9383/"
  #"Topology"}
@string{tams="tams/0002-9947/"
  #"Transactions of the American Mathematical Society"}
%</abbrevs>
%    \end{macrocode}
%
% \section{To Do}
%
% ---When there is no author or editor info to create a label from: Use
%    the initial letters of all the words in the title. Plus the year.
%    Maybe year first.
%
% ---Add linelength and indent options to control the output?
%
% ---Discuss apacite "originalfoo" fields etc.
%
% ---Discuss Beebe's work.
%
% ---Add bibliography.
%
% ---Add AUDIO, VIDEO entry types.
%
% ---Add a field for MR subject classification numbers and the like?
%
% ---Write a converter to convert from typical .bib data to preferred
%    form. Have to go via perl or something to capture STRING defs and
%    PREAMBLE and interspersed comments? Or emacs lisp? Provide .bst
%    version as fallback.
%
% ---Alpha labels: add numbers after sorting? subscript option? L3Y2a
%    option.
%
% ---Test multi-author articles with ten-plus authors. What happens
%    with the alpha labels then?
%
% ---For url field especially, check length and prebreak by hand instead
%    of relying on \bibtex/'s slapdash stick-in-a-percent-at-column-72
%    regardless of where it happens to fall.
%
% ---How about a general `contributor' field.
%
% ---Test with a wimpy older version of \bibtex/.
%
% \CheckSum{24}
% \Finale
